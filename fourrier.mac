/*
 * (C) Dimiter Prodanov
 *
 * @version 1.0 Date 06 April 2014
 *
 * @author Dimiter Prodanov
 * 		  IMEC

 * @contents
 * This library computes Fourier transforms
 *  I thank also Robert Dodier for  the rule handling code 
 *  and the code handling distributive properties of FT and IFT
 * 
 * @license This library is free software; you can redistribute it and/or
 *      modify it under the terms of the GNU Lesser General Public
 *      License as published by the Free Software Foundation; either
 *      version 2.1 of the License, or (at your option) any later version.
 *
 *      This library is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *       Lesser General Public License for more details.
 *
 *      You should have received a copy of the GNU Lesser General Public
 *      License along with this library; if not, write to the Free Software
 *      Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 if get('fourrier,'version)=false then ( 
	load("dist.lisp")
 )$
 
fourinfo([_package]):=
block(
	disp("package name: fourrier.mac (c)"),
	disp("author: Dimiter Prodanov"),
	disp("version: 1.1"),
	disp("Recommended location: share/contrib"),
	disp("last update: 06 Apr, 2014"),
	disp("")
)$




noundisp:true$

declare (FT, linear)$
declare (IFT, linear)$
declare_distributes_over (FT, ["[","="])$
declare_distributes_over (IFT, ["[","="])$

( "transitive rules",
matchdeclare(seq, opEqp),
    defrule(fttrans, FT(seq),  FT(part(seq,1)) = FT (part(seq,2))),
    defrule(ifttrans, IFT(seq), IFT(part(seq,1)) = IFT(part(seq,2)))
)$

( "Basic FT IFT  rules",
matchdeclare([ t, f ], atom, x, true),
    defrule(ft_ift, FT(IFT(t)), t),
    defrule(ift_ft, IFT(FT(t)), t),
    defrule(ftc, FT(1), delta(f)),
    defrule(iftc, IFT(1), delta(t)),
    defrule(ft_main, FT(x), integrate(x*exp(-%i*2*%pi*f*t),t,-inf, inf )),
    defrule(ift_main, IFT(x), integrate(x*exp( %i*2*%pi*f*t),f,-inf, inf ))
)$

( "special functions",
matchdeclare([t, f], lambda([u], not(constantp(u)) and atom(u)), T, atom, a, lambda([u], freeof(t,a) ) ),
    /* **   special functions
        */
    defrule(ft_delta, FT(delta(t)), 1),
    defrule(ift_delta, IFT(delta(f)), 1),
    defrule(ft_t, FT(t), -2* %pi* 1/(f^2) ), 
    defrule(ift_t,  IFT(1/(f^2)), -t/(2* %pi) ), 
    defrule(ft_rect, FT(_rect(t, T)), 1/abs(T)*'sinc(f,1/T)),
    defrule(ift_rect, IFT(_rect(f, T)), 1/abs(T)*'sinc(t,1/T)),
    defrule(ft_triang, FT(_triang(t, T)), 1/abs(T)*('sinc(f,1/T))^2),
    defrule(ift_triang, IFT(_triang(f, T)), 1/abs(T)*('sinc(t,1/T))^2),
    defrule(ft_step, FT(_step(t)), 1/(2*%i*%pi*f) +delta(f)),
    defrule(ft_signum, FT(signum(t)), 1/(2*%i *%pi*f) ),
    defrule(ift_signum, IFT (1/f), 2*%i * %pi*signum(t) ),
   
    defrule(ft_sinc, FT(_sinc(t,T)), 1/abs(T) *'rect(f,1/T)),
    defrule(ift_sinc, IFT(_sinc(f,T)), 1/abs(T) *'rect(t,1/T)),
    defrule(ft_sinc2, FT(_sinc(t,T)^2), 1/abs(T) *'triang(f, 1/T)),
    
    defrule(ft_sin, FT(sin(t)), 1/(2*%i)*(delta(f - 1/(2*%pi)) -  delta(f + 1/(2*%pi))) ),
    defrule(ft_sin2, FT(sin(t^2)), -sqrt(%pi) *sin(%pi^2 *f^2 -%pi/4 ) ),
    defrule(ft_cos, FT(cos(t)), 1/(2)*(delta(f - 1/(2*%pi)) +  delta(f + 1/(2*%pi))) ),
    defrule(ft_cos2, FT(cos(t^2)), sqrt(%pi) *cos(%pi^2 *f^2 -%pi/4 ) )
)$

( "differentiation and integration",
matchdeclare([t, f, axt], lambda([u], not(constantp(u)) and atom (u)), g, true, n, atom, a, atom),
    defrule(ft_diff1, FT('diff(g(t), t, n)),  (%i*2*%pi*f)^n *FT(g(t)) ),
	defrule(ft_int1, FT('integrate(g(t), t)),  %i/(2*%pi*f)*FT(g(t)) ),
    defrule(ft_diff2, FT(axt), lambda([axt], ftPow(axt) )   )
)$

ftPow(axt):= block([g,s,n], 
   s:inargsa(axt),    
   g:s[2],  
   s:inargsa(s[1]),     
   n:s[2],
   splitByPow(axt, t), 
   return (1/(-%i*2*%pi)^n *'diff(FT(g),f,n)  ) 
)$

splitByPow(V, t) := block( [ret,  %A:false, %N:0],
   matchdeclare(%A, nlistp, t, atom, %N,  nlistp),
   defmatch (powp,  %A*t^%N, t),
   powp(V,t),  
   "print (%A, %N)",
   ret: [ %A, %N],
   return(ret)
)$

("linear rule",
matchdeclare(V, opMp, [t, f ], lambda([u], not(constantp(u)) and symbolp(u))),
	defrule (simpftlin, FT(V), ftprodsimp(V, t) ),
	defrule (simpiftlin, IFT(V), iftprodsimp(V,f) )
)$

(matchdeclare(_c, constantp, [t, f ], lambda([u], not(constantp(u)) and symbolp(u)), fn, symbolp),
	defrule (simftc, FT(fn(_c)), ftcsimp(fn(_c))),
	defrule (simiftc, IFT(fn(_c)), iftcsimp(fn(_c)))
)$

ftprodsimp(V, s):=oprodsimp(V, s, FT)$
ftcsimp(V):=oconstsimp(V, op(V), FT)$
iftprodsimp(V, s):=oprodsimp(V, s, IFT)$
iftcsimp(V):=oconstsimp(V, op(V), IFT)$

oprodsimp(V, s, OP ):= block( [ %A, %R, res ],
	matchdeclare(%A, lambda([x], freeof(s, x)), %R, lambda([x], not freeof(s, x)), s, true),
	defmatch (oprodp,  %A*%R, s),
	res: oprodp(V, s),
	if (res#false) then
		return (%A*OP(%R))
	else return (OP(V))
)$

("shifting",
matchdeclare(V, lambda([x], not freeof(t, x)) , [t, f ], lambda([u], not(constantp(u)) and symbolp(u)), fn, symbolp),
	defrule (simftshift, FT(fn(V)), ftsumsimp(fn(V), t, f)),
	defrule (simiftshift, IFT(fn(V)), iftsumsimp(fn(V), f, t))
)$

ftsumsimp(V, s, f):=block( [ %A, p1, p2, res],
matchdeclare(%A, lambda([x], freeof(s, x) ), s, atom),
	defmatch (osump,  %A + s, s),
	p2:op(V),
	p1:first(inargsa(V)),
	res: osump(p1, s),
	if (res#false) then
		return (FT(p2(s))*exp( 2*%pi*f*%A))
	else return (FT(V))
)$

iftsumsimp(V, s, t):=block( [ %A, p1, p2, res],
	p2:op(V),
	p1:first(inargsa(V)),
	res: osump(p1, s),
	if (res#false) then
		return (IFT(p2(s))*exp(- 2*%pi*t*%A))
	else return (IFT(V))
)$
 

oconstsimp(V, fn, OP):= block( [%c] ,
	matchdeclare (%c, constantp, fn, symbolp),
	defmatch (ofconst, fn(%c), fn),
	ofconst(V, fn),
	return (fn(%c)*OP(1))
)$

("imaginary arguments",
 matchdeclare([ it ], lambda([u], is(splitBy1(u,%i)#false) ) ),
 defrule(ft_ie, FT(exp(it)), delta(f - 1/(2*%pi) )   )
)$

/* assume FT rules are all named ftsomething.
 * extracting the list like this is maybe no more or less problematic
 * than maintaining it by hand.
 */
specific_FT_rules : sublist (rules, lambda ([a], smismatch ("ft", sconcat (a)) = 3 and a # 'ft_main))$
specific_IFT_rules : sublist (rules, lambda ([a], smismatch ("ift", sconcat (a)) = 4 and a # 'ift_main))$


( "scaling",
matchdeclare(V, opMp, t, symbolp, g, symbolp, a, atom),
    defrule (simftscale, FT (g(V)), ftprodsimp2 (g(V), t )),
	defrule (simiftscale, IFT (g(V)), iftprodsimp2 (g(V), t ))
)$

iftprodsimp2(V, s):=oprodsimp2(V, s, IFT)$
ftprodsimp2(V, s):=oprodsimp2(V, s, FT)$

oprodsimp2(V, s, OP ):= block( [ %B,  res, y:V ],
	if op(V)=OP then y:first(inargsa(V)),
	matchdeclare( %B , lambda([x], freeof(s, x) and atom (x)), s, atom, g, symbolp),
	defmatch (oprod2p,  g(%B*s), s),
	res: oprod2p(y, s),
	
	if (res#false) then (
		res:subst (s/%B, s, y),
		"print (%B)",
		return ([OP(res), %B])
	)		
	else return (OP(V)) 	
)$

/* Forward  Fourier trnsform */
ft(expr,t,f):= block([ ret, p1, p2, fr:1 ],
	ret:expand(expr),
	ret:FT(ret), 
    assume(f>0),  
    if opIftp(expr) then return (apply1 (ret,  ft_ift)),   
 
	"print (ret)",
	ret: apply1(ret, simpftlin, simftc, simftshift, simftscale),
	if listp(ret) then (
		print ("sc ", ret),
		fr:part(second(ret),1),
		ret: first(ret)
	),
	ret:apply (apply1, cons (ret, specific_FT_rules)),
	"print (ret)",
	if not freeof (t, ret) then
		ret:apply1 (ret, ft_main),
	if fr#1 then 
		ret: 1/abs(fr)*subst( f/fr, f, ret),	
	"ret:apply1 (ret, expand_rect, expand_step)",
    ret:ratsimp(ret),
    ret:expand(ret),
 return (ret)
)$

/* Inverse  Fourier trnsform */
ift(expr,f,t):= block([ ret:IFT(expr), p1, p2, fr:1 ],
   assume(t>0), 
    if opFtp(expr) then (
       ret: apply1 (ret,  ift_ft),
       return (ret)
    ),   
 
	ret: apply1(ret, simpiftlin, simiftc, simiftshift, simiftscale),
	if listp(ret) then (
		print ("sc ", ret),
		fr:part(second(ret),1),
		ret: first(ret)
	),
    ret:apply (apply1, cons (ret, specific_IFT_rules)),
	"print (ret)",
    ret:apply1 (ret, ift_main),
	if fr#1 then 
		ret: 1/abs(fr)*subst( t/fr, t, ret),	
	"ret:apply1 (ret, expand_rect, expand_step)",
    ret:ratsimp(ret),
    ret:expand(ret),
 return (ret)
)$

/***************
*   Special functions
************/


/* workaround Maxima's weird function concept
*/  
rect(t,T):=funmake (_rect, [t ,T])$    
_rect(t,T):= if abs (t)<= T/2 then return(1) else return (0)$
 

triang(t,T):=funmake (_triang, [t ,T])$
_triang(t,T):= block(
    if abs (t)<= T then return (1 - abs(t)/T)
    else return (0)
)$

stp(t):=funmake (_step, [t])$
_step(t):=  if t>=0 then return (1) else return (0)$

sinc(t,T):=funmake (_sinc, [t ,T] )$
_sinc(t, T):= block(
    if t#0 then return (%pi*sin(t*T*%pi)/(t*T))
    else return (1)
)$


/*****************************
*         Private functions
*****************************/


put('fourrier, 1.1,'version)$

/*******************************
*         Utility functions
****************************/  
nlistp(_x):=  not(listp(_x))$

splitBy1(V, t):= block([A:false],
    matchdeclare (A, atom, t, atom),
    defmatch (prodp,  A*t, t),
    prodp(V,t),  
    return(A)
)$


/* utility like args, but avoids / or - */
inargsa(z):=block( 
if (atom(z)) then return ([z])
else return( substinpart("[",z,0))
)$

opEqp(V):= isOp (V, "=")$
opMp(V):= isOp (V, "*")$

opFtp(V):= isOp (V, FT)$
opIftp(V):= isOp (V, IFT)$

isOp(V, oper):= block(
    if atom(V) then return (false)
    else return (is(op(V) = oper)  or is(op(V) = nounify(oper)))
)$
/******* END ******************/